# Zed IDE Diagnostics: Instructions for LLM Agents

This document provides instructions for LLM agents on how to programmatically interact with and utilize the Diagnostics features within the Zed IDE environment.

## 1. Understanding Diagnostics for LLM Agents

Zed IDE diagnostics provide structured information about code quality, errors, warnings, and hints, generated by Language Servers (LSPs). For an LLM agent, these diagnostics serve as critical input for automated code analysis, bug fixing, and code improvement tasks.

## 2. Accessing Diagnostic Information

LLM agents should assume access to diagnostic information in a structured format (e.g., JSON) provided by the Zed IDE's underlying APIs or through a simulated environment that exposes this data. Key information for each diagnostic includes:

- **Severity:** (e.g., `error`, `warning`, `info`, `hint`)
- **Message:** A human-readable description of the issue.
- **File Path:** The absolute path to the file containing the issue.
- **Line Number & Column:** Precise location of the issue within the file.
- **Code Snippet:** The relevant code segment associated with the diagnostic.

## 3. Core Instructions for LLM Agents

### 3.1. Identify and Prioritize Errors

**Instruction:** When initiating any code analysis or modification task, the LLM agent _must_ first retrieve and process all available diagnostic messages. Prioritize addressing diagnostics with `severity: error` before any other type.

**Rationale:** Errors indicate critical issues that prevent compilation or correct execution. Resolving these is paramount for code functionality and stability.

**Actionable Steps for LLM Agent:**

1.  **Retrieve Diagnostics:** Query the environment's API to get a list of all current diagnostics for the project.
2.  **Filter by Severity:** Create a subset of diagnostics where `severity` is `error`.
3.  **Iterate and Address:** For each error diagnostic:
    a. Read the `file_path`, `line_number`, and `message`.
    b. Read the content of the specified file using `read_file` to get the surrounding context.
    c. Analyze the `message` and `code_snippet` to understand the root cause.
    d. Formulate a precise code modification (e.g., using `replace` or `write_file`) to resolve the error.
    e. Apply the fix and re-evaluate diagnostics to confirm resolution.

### 3.2. Contextualize Diagnostics for Accurate Fixes

**Instruction:** When a diagnostic message is encountered, the LLM agent _must_ use the provided `file_path`, `line_number`, and `code_snippet` to read the relevant code and its surrounding context. This contextual understanding is crucial for generating accurate and idiomatic fixes.

**Rationale:** A diagnostic message alone might not provide enough information to understand the full implications of a change. Surrounding code, function definitions, and variable scopes are essential for correct modifications.

**Actionable Steps for LLM Agent:**

1.  **Receive Diagnostic:** Obtain a diagnostic object with `file_path`, `line_number`, `column`, and `message`.
2.  **Read File Content:** Use the `read_file` tool with the `file_path` to get the complete content of the file.
3.  **Extract Context:** Based on `line_number` and `column`, extract the problematic line and several lines before and after it. Consider the scope of the identified issue (e.g., within a function, class, or block).
4.  **Analyze and Plan:** Combine the diagnostic `message` with the extracted code `context` to:
    a. Determine the exact nature of the problem.
    b. Identify dependencies or related code that might be affected by a change.
    c. Formulate a solution that aligns with existing code style and patterns.
5.  **Propose/Apply Fix:** Generate a `replace` or `write_file` operation with `old_string` and `new_string` that includes sufficient surrounding context to ensure the change is precise and correct.

## 4. Advanced Considerations for LLM Agents

- **Iterative Refinement:** After applying a fix, always re-check diagnostics. A fix for one issue might introduce another, or reveal previously hidden problems.
- **Code Style and Conventions:** When generating fixes, adhere to the project's established code style and conventions, which can be inferred from existing code or configuration files (e.g., `.eslintrc.js`, `tsconfig.json`).
- **Test Generation/Modification:** For significant changes, consider if existing tests need to be updated or new tests need to be generated to cover the fix.
